#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <elf.h>
#include <openssl/sha.h>
#include "httpApi.h"
#include "getHash.h"
#include "ssllib.h"
#define ERR(...) \
    do { fprintf(stderr,__VA_ARGS__); \
         fputc('\n',stderr);          \
         exit(EXIT_FAILURE);}         \
    while(0)

#define FLAG_NONE 0
#define FLAG_CSV  1

char g_virus_path[260]={""};
char g_file_hash[50]={""};
extern char *g_pass;
extern int g_virus_size;
/*
https://github.com/enferex/sectsum
*/
static size_t safe_fread(void *buf, size_t sz, FILE *fp)
{
    if (fread(buf, 1, sz, fp) != sz)
    {
        if (ferror(fp))
		{
			printf("Error %d reading from input file", ferror(fp));
		}
    }

    return sz;
}


/* 32/64 Elf structure accessor:
 * _b: Name of the structure following the Elf32 or Elf64 prefix
 * _f: Field of the structure to access
 * _s: Bit size (32 or 64)
 * _p: void * to the structure
 */
#define E(_b, _f, _s, _p) ((_s==32) ? \
    ((Elf32_##_b *) _p)->_f : ((Elf64_##_b *) _p)->_f)

#define E_SZ(_b, _s) ((_s==32) ? \
    sizeof(Elf32_##_b) : sizeof(Elf64_##_b))

                         

static int print_sect(
    int                  instance,
    const char          *fname,
    const char          *sect_name,
    size_t               size,
    const unsigned char *hash)
{
    int i;

    if (strlen(sect_name) == 0)
      sect_name = "<none>";
	char s_hash[40]={""};
    for (i=0; i<160/8; ++i)
	{
		char temp[2];
		sprintf(temp, "%02x", hash[i]);
		strcat(s_hash,temp);
	}
	strncpy(g_file_hash,s_hash,sizeof(g_file_hash));
	char buf[70]={""};
	strcat(buf,s_hash);
	strcat(buf,g_pass);
	
	int hash_size=33;
	char *md5hash = malloc(hash_size*(sizeof(char)));
	if(md5hash == NULL) return 0;
	memset(md5hash,0,hash_size*sizeof(char)); //初始化为0
	getStringmd5(buf,md5hash);
	//char *token=MDString(buf);
	int flag=query_virus2(s_hash,md5hash);
	g_virus_size=size;
	while(flag==-1){
		sleep(1);
		flag=query_virus2(s_hash,md5hash);
	}
	if(flag){
		free(md5hash);
		return 1;
	}else{
		free(md5hash);
		return 0;
	}
}

//-1 not ELF,0 getHash error,1 getHash ok,2 packed
static int disp_sections(FILE *fp, const char *fname)
{
    int i, n_sections, bits;
    void *hdr, *shdr;
    long here;
	int print_sect_result=0;
    uint64_t strtbl_idx, shent_sz, sect_sz;
    char *strtbl, *name, ident[EI_NIDENT];
    unsigned char hash[32], *data;
    Elf32_Ehdr hdr32 = {{0}};
    Elf64_Ehdr hdr64 = {{0}};

    safe_fread(ident, EI_NIDENT, fp);
    if (strncmp(ident, ELFMAG, strlen(ELFMAG)) != 0)
	{
		printf("%s\tThis is not an ELF file\n",fname);
		return -1;
	}// ERR("This is not an ELF file");

    if (ident[EI_CLASS] == ELFCLASS32) 
    {
        hdr = (Elf32_Ehdr *)&hdr32;
        bits = 32;
    }
    else if (ident[EI_CLASS] == ELFCLASS64)
    {
        hdr = (Elf64_Ehdr *)&hdr64;
        bits = 64;
    }
    else
	{
		printf("Unknown binary word-size\n");
		return -1;
	}

    /* Read the ELF header */
    rewind(fp);
	printf("%s\t",fname);
    safe_fread(hdr, E_SZ(Ehdr, bits), fp);
    n_sections = E(Ehdr, e_shnum, bits, hdr);
	if(n_sections==0){
		char *file_md5=fileMd5(fname);
		printf("\tWarning:Unknow Elf File!\n");
		free(file_md5);
		return 2;
	}
    strtbl_idx = E(Ehdr, e_shstrndx, bits, hdr);
    shent_sz = E(Ehdr, e_shentsize, bits, hdr);

    if (!(shdr = malloc(shent_sz)))
    {
		printf("Could not allocate enough memory to parse a section header\n");
	}  //ERR("Could not allocate enough memory to parse a section header");

    /* Get the section header for the string table */
    fseek(fp, E(Ehdr, e_shoff, bits, hdr) + strtbl_idx * shent_sz, SEEK_SET);
    safe_fread(shdr, shent_sz, fp);

    /* Allocate and read the string table */
    if (!(strtbl = malloc(E(Shdr, sh_size, bits, shdr))))
    {
		printf("Could not allocate enough memory to store the string table\n");
		return -1;
	} // ERR("Could not allocate enough memory to store the string table");
    fseek(fp, E(Shdr, sh_offset, bits, shdr), SEEK_SET);
    safe_fread(strtbl, E(Shdr, sh_size, bits, shdr), fp);

    /* Header */
	
    fseek(fp, E(Ehdr, e_shoff, bits, hdr), SEEK_SET);
    for (i=0; i<n_sections; ++i)
    {
        safe_fread(shdr, shent_sz, fp);
        name = strtbl + E(Shdr, sh_name, bits, shdr);
        sect_sz = (uint64_t)E(Shdr, sh_size, bits, shdr);

        /* Read the data */
        if (!(data = malloc(E(Shdr, sh_size, bits, shdr))))
        {
			printf("Could not allocate enough memory to store section data\n");
			return -1;
		} // ERR("Could not allocate enough memory to store section data");
        here = ftell(fp);
        fseek(fp, E(Shdr, sh_offset, bits, shdr), SEEK_SET);
        safe_fread(data, E(Shdr, sh_size, bits, shdr), fp);
        fseek(fp, here, SEEK_SET);

        /* Calc the hash (160 bits) */
        SHA1(data, E(Shdr, sh_size, bits, shdr), hash);
		
		if(strcmp(name,".text")==0){
			//printf("%s:%s:%zu\n",fname,hash,sect_sz);
			print_sect_result=print_sect(i+1, fname, name, sect_sz, hash);
			break;
		}
    }
	if(print_sect_result==1){
		free(shdr);
		free(strtbl);
		strtbl = NULL;
		return 1;
	}else{
		free(shdr);
		free(strtbl);
		strtbl = NULL;
		return 0;
	}
 
}

//getHash by filePath
int getHash(char *fname)
{
    FILE *fp;
	int disp_sections_result;
    if (!(fp = fopen(fname, "r"))){
		printf("Could not open file: %s\n", fname);
		return -1;
	}
	strncpy(g_virus_path,fname,260);
	disp_sections_result=disp_sections(fp, fname);
	fclose(fp);
	return disp_sections_result;  
}

