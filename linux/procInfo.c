#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include "getHash.h"
#include <sys/types.h>
#include "httpApi.h"
#include "getIp.h"
#include "tcpInfo.h"
#include "fileInfo.h"
#include "killVirus.h"
#include "ssllib.h"
#include "cJSON.h"
#include "healthMontior.h"
#define NAME_SIZE 20
#define BUF_SIZE 50

extern char g_virus_path[260];
extern char g_file_hash[50];
extern int g_clean_type;
extern char g_startType[20];
extern char g_client_ip[64];
extern char *g_os_type;
extern char g_os_version[260];
int g_virusCount=0;
int g_packedCount=0;
int g_scanCount=0;
int g_cleanedCount=0;
int no_file_id=1000;
int tcpinfo_size=512;

char *nofile_hash="0000000000000000000000000000000000000000";
extern char *g_pass;
extern int g_virus_size;
extern char g_virus_hash[50];
extern char g_virus_name[20];
extern char g_blacklist[2];
struct proc_list{
        pid_t pid;
        pid_t ppid;
        char name[NAME_SIZE];
        char status;
        struct proc_list *next;
};

struct proc_list *inport_list(char *);
void getPathAndClean(struct proc_list *);
void getPathNotClean(struct proc_list *);
int read_info(char *,struct proc_list *);
void free_list(struct proc_list *);
int is_num(char *);


struct proc_list *inport_list(char *dir){
        DIR *dsptr;
        struct dirent *dptr;
        struct proc_list *head=NULL,*ptr=NULL;
        if((dsptr=opendir(dir))==NULL){
                printf("Error open the dir %s\n",dir);
                exit(-1);                
        }
        
        // read all the dir and file under directory "dir" ;
        while((dptr=readdir(dsptr))!=NULL){
                if(is_num(dptr->d_name)==0){ // determine if the d_name is a number ;
                        
                        // request some memeory , some = sizeof(struct proc_list) ;
                        struct proc_list *item = (struct proc_list *)malloc(sizeof(struct proc_list));
                
                        if(item==NULL){
                                printf("memory allocate error !\n");
                                // must do some free() work here !
                                free_list(head);
                                exit(0);
                        }
                
                        memset(item,0,sizeof(struct proc_list));
                        
                        // link the item to proc_list list ;
                        if(head==NULL)
                                        head=ptr=item;
                        else{
                                ptr->next=item;
                                ptr=ptr->next;                        
                        }
                
                        item->pid = atoi(dptr->d_name);
                        
                        if(read_info(dptr->d_name,item)!=0){ // determine if read error occurred ;
                                // must do some free() work here ;
                                free_list(head);
                                exit(-1);                        
                        }                        
                }
        }
        closedir(dsptr);
        return head;
}

int read_info(char *d_name,struct proc_list *item){
	char dir[20];
	char name[NAME_SIZE];
	char buffer[BUF_SIZE];
	FILE *fptr;
	if(strlen(d_name)>19){
		exit(0);
	}
	sprintf(dir,"%s%s","/proc/",d_name);
	chdir(dir);        
	fptr=fopen("status","r");
	if(fptr==NULL){
			printf("Error reading %s%s\n",dir,"status");
			return -1;
	}
	while(fgets(buffer,BUF_SIZE-1,fptr))
	{
		if(strstr(buffer,"Name:")){
			sscanf(buffer,"%s%s",name,item->name);
		}else if(strstr(buffer,"PPid:")){
			sscanf(buffer,"%s%d",name,&(item->ppid));
		}else if(strstr(buffer,"State:")){
			sscanf(buffer,"%s %c",name,&(item->status));
		}
	}
	fclose(fptr);
	return 0;
}

void free_list(struct proc_list *head){
        struct proc_list *ptr;
        while(head!=NULL){
                ptr=head;
                head=head->next;
                free(ptr);
        }
}

void getCmdline(int pid,char* cmdline,int cmdline_size)
{
	FILE * pFile;
	char mystring [200];
	
	char proc_cmdline[64]={""};
	sprintf(proc_cmdline,"/proc/%d/cmdline",pid);
	
	pFile = fopen (proc_cmdline, "r");
	if (pFile == NULL){
		perror ("Error opening file");
		exit(0);
	}
        
	while( fgets (mystring , 200 , pFile) != NULL){
		strncpy(cmdline,mystring,cmdline_size);
	}
	fclose (pFile);
}

void getPathNotClean(struct proc_list *head){
	struct proc_list *ptr;
	int scan_flag=1;
	int hash_size=33;
	int buf_size=200;
	char *hashReportBuf = (char*)malloc(buf_size*(sizeof(char)));
	if(hashReportBuf == NULL) return;
	memset(hashReportBuf,0,buf_size*sizeof(char));

	strcat(hashReportBuf,g_client_ip);
	strcat(hashReportBuf,g_pass);
	char *mtoken = (char*)malloc(hash_size*(sizeof(char)));
	if(mtoken == NULL) return;
	memset(mtoken,0,hash_size*sizeof(char));
	getStringmd5(hashReportBuf,mtoken);
	free(hashReportBuf);
	
	//hashReport
	cJSON *hashReportJsonRoot, *hashReportArray ,*hashReportObject;
	hashReportJsonRoot = cJSON_CreateObject();
	cJSON_AddStringToObject(hashReportJsonRoot, "type", "hashReport");
	cJSON_AddItemToObject(hashReportJsonRoot, "value", hashReportArray=cJSON_CreateArray());
	cJSON_AddStringToObject(hashReportJsonRoot, "client_ip", g_client_ip);	
	cJSON_AddStringToObject(hashReportJsonRoot, "token", mtoken);
	cJSON_AddStringToObject(hashReportJsonRoot, "platform", g_os_type);
	cJSON_AddStringToObject(hashReportJsonRoot, "os_version", g_os_version);
	cJSON_AddStringToObject(hashReportJsonRoot, "start_type", g_startType);
	
	//insetViru
	cJSON *insertVirusJsonRoot, *insertVirusArray ,*insertVirusObject;
	insertVirusJsonRoot = cJSON_CreateObject();
	cJSON_AddStringToObject(insertVirusJsonRoot, "type", "insertVirus");
	cJSON_AddItemToObject(insertVirusJsonRoot, "value", insertVirusArray=cJSON_CreateArray());
	cJSON_AddStringToObject(insertVirusJsonRoot, "client_ip", g_client_ip);	
	cJSON_AddStringToObject(insertVirusJsonRoot, "token", mtoken);
	cJSON_AddStringToObject(insertVirusJsonRoot, "platform", g_os_type);
	cJSON_AddStringToObject(insertVirusJsonRoot, "os_version", g_os_version);
	cJSON_AddStringToObject(insertVirusJsonRoot, "start_type", g_startType);
	free(mtoken);
	//////////////////////////////////////////////////////////////////////////
//	map<int, string> mapFileHash;
//	map<int, string>::iterator iter;
//	mapFileHash.insert(map<int,string>::value_type (1,"0"));
	//////////////////////////////////////////////////////////////////////////
	
	//获取pid
	for(ptr=head;ptr!=NULL;ptr=ptr->next){
    
    char *link = (char*)malloc(20*(sizeof(char)));
	if(link == NULL) return;
	memset(link,0,20*sizeof(char));
	
	
	char *path = (char*)malloc(260*(sizeof(char)));
	if(path == NULL) return;
	memset(path,0,260*sizeof(char));
	if((ptr->pid)>99999999){
		exit(0);
	}
	sprintf(link, "/proc/%d/exe",ptr->pid);
	//读取exe link
	int flag=readlink(link, path, 260);
	
	//路径hash
	char *path_hash = (char*)malloc(hash_size*(sizeof(char)));
	if(path_hash == NULL) return;
	memset(path_hash,0,hash_size*sizeof(char));
	getStringmd5(path,path_hash);
	

	if(flag!=-1){
			//mapFileHash.insert(map<int,string>::value_type (g_virusCount,path_hash));
			//获取代码段hash
			int isVirus=getHash(path);
			
			//扫描object数加1
			g_scanCount++;
			
			//linux sleep函数单位秒
			sleep(0.5);
			
			//获取文件时间属性
			int time_size=40;
			char *access_time = (char*)malloc(time_size*(sizeof(char)));
			if(access_time == NULL) return;
			memset(access_time,0,time_size*sizeof(char));
			char *create_time = (char*)malloc(time_size*(sizeof(char)));
			if(create_time == NULL) return;
			memset(create_time,0,time_size*sizeof(char)); 
			char *modify_time = (char*)malloc(time_size*(sizeof(char)));
			if(modify_time == NULL) return;
			memset(modify_time,0,time_size*sizeof(char));
			
			//获取进程TCP网络连接信息
			int tcpinfo_size = 512;
			char *tcpinfo = (char*)malloc(tcpinfo_size*(sizeof(char)));
			if(tcpinfo == NULL) return;
			memset(tcpinfo,0,tcpinfo_size*sizeof(char)); //初始化为0
			

			//获取进程UDP网络连接信息
			int udpinfo_size = 512;
			char *udpinfo = (char*)malloc(udpinfo_size*(sizeof(char)));
			if(udpinfo == NULL) return;
			memset(udpinfo,0,udpinfo_size*sizeof(char)); //初始化为0
			
			//获取zombie net信息
			int zombie_ip_size = 512;
			char *zombie_ip = (char*)malloc(zombie_ip_size*(sizeof(char)));
			if(zombie_ip == NULL) return;
			memset(zombie_ip,0,zombie_ip_size*sizeof(char)); //初始化为0
			
			//net信息获取
			getNetInfoByPid(ptr->pid,tcpinfo,tcpinfo_size,udpinfo,udpinfo_size,zombie_ip,zombie_ip_size);
			
			//获取进程cmdline
			int cmdline_size = 512;
			char *cmdline = (char*)malloc(cmdline_size*(sizeof(char)));
			if(cmdline == NULL) return;
			memset(cmdline,0,cmdline_size*sizeof(char)); //初始化为0
			getCmdline(ptr->pid,cmdline,cmdline_size);
			
			//发现病毒
			if(isVirus==1){
				g_virusCount++;
				
				//获取文件md5
				char *file_md5=fileMd5(g_virus_path);
			
				//获取文件大小
				int file_size=get_file_size(g_virus_path);
				
			
				char *kill="not kill";
				
				//扫描数
				char *virus_id = (char*)malloc(5*(sizeof(char)));
				if(virus_id == NULL) return;
				memset(virus_id,0,5*sizeof(char)); //初始化为0
				//char virus_id[10];
				if(g_scanCount>99999){
					exit(0);
				}
				sprintf(virus_id,"%d",g_scanCount);
				
				//获取文件时间信息
				int access=getFileTimeInfo(g_virus_path,access_time,create_time,modify_time);
				
				//获取进程运行时间
				int proc_runtime=getRunTime(g_virus_path);
				
				
				//病毒信息封装
				cJSON_AddItemToArray(insertVirusArray,insertVirusObject=cJSON_CreateObject());
				cJSON_AddStringToObject(insertVirusObject, "virus_name", g_virus_name);
				cJSON_AddStringToObject(insertVirusObject, "section_hash", g_virus_hash);
				cJSON_AddNumberToObject(insertVirusObject, "section_size", g_virus_size);
				cJSON_AddStringToObject(insertVirusObject, "file_md5", file_md5);
				cJSON_AddNumberToObject(insertVirusObject, "file_size", file_size);
				cJSON_AddStringToObject(insertVirusObject, "imphash", "");
				cJSON_AddNumberToObject(insertVirusObject, "is_cert", 0);
				cJSON_AddStringToObject(insertVirusObject, "cert_signer", "");
				cJSON_AddStringToObject(insertVirusObject, "cert_details", "");
				cJSON_AddStringToObject(insertVirusObject, "cmdline", cmdline);
				cJSON_AddNumberToObject(insertVirusObject, "is_service", 0);
				cJSON_AddStringToObject(insertVirusObject, "proc_service_name", "");
				cJSON_AddStringToObject(insertVirusObject, "virus_path", g_virus_path);
				cJSON_AddStringToObject(insertVirusObject, "parent_path", "");
				cJSON_AddStringToObject(insertVirusObject, "remote_ip", zombie_ip);
				cJSON_AddStringToObject(insertVirusObject, "killed", kill);
				cJSON_AddNumberToObject(insertVirusObject, "proc_runtime", proc_runtime);
				cJSON_AddStringToObject(insertVirusObject, "access_time", access_time);
				cJSON_AddStringToObject(insertVirusObject, "create_time", create_time);
				cJSON_AddStringToObject(insertVirusObject, "modify_time", modify_time);
				cJSON_AddStringToObject(insertVirusObject, "virus_id", virus_id);
				if (strlen(tcpinfo)>0 ||strlen(udpinfo)>0)
				{
					char netInfo[1024]={""};
					strcat(netInfo,"{\"TCP_STAT\":\"");
					strcat(netInfo,tcpinfo);
					strcat(netInfo,"\",");
					strcat(netInfo,"\"UDP_STAT\":\"");
					strcat(netInfo,udpinfo);
					strcat(netInfo,"\"}");
					cJSON_AddStringToObject(insertVirusObject, "info", netInfo);
				}else{
					cJSON_AddStringToObject(insertVirusObject, "info", "");
				}
										
				free(virus_id);
				free(file_md5);
				
			}
			//elf文件加壳
			if(isVirus==2){
				char *kill2="not kill";
				g_packedCount++;
				//int tcpinfo_size=60;
				
				char virus_id[10];
				if(g_scanCount>99999){
					exit(0);
				}
				sprintf(virus_id,"%d",g_scanCount);
				
				//获取文件md5
				char *file_md5=fileMd5(g_virus_path);
			
				//获取文件大小			
				int file_size=get_file_size(g_virus_path);
				
				//获取文件时间属性
				int access=getFileTimeInfo(g_virus_path,access_time,create_time,modify_time);
				int proc_runtime=getRunTime(g_virus_path);
				cJSON_AddItemToArray(insertVirusArray,insertVirusObject=cJSON_CreateObject());
				cJSON_AddStringToObject(insertVirusObject, "virus_name", "Dangerious Elf");
				cJSON_AddStringToObject(insertVirusObject, "section_hash", file_md5);
				cJSON_AddNumberToObject(insertVirusObject, "section_size", file_size);
				cJSON_AddStringToObject(insertVirusObject, "file_md5", file_md5);
				cJSON_AddNumberToObject(insertVirusObject, "file_size", file_size);
				cJSON_AddStringToObject(insertVirusObject, "virus_path", g_virus_path);
				cJSON_AddStringToObject(insertVirusObject, "parent_path", "");
				cJSON_AddStringToObject(insertVirusObject, "remote_ip", zombie_ip);
				cJSON_AddStringToObject(insertVirusObject, "killed", kill2);
				cJSON_AddNumberToObject(insertVirusObject, "proc_runtime", proc_runtime);
				cJSON_AddStringToObject(insertVirusObject, "access_time", access_time);
				cJSON_AddStringToObject(insertVirusObject, "create_time", create_time);
				cJSON_AddStringToObject(insertVirusObject, "modify_time", modify_time);
				cJSON_AddStringToObject(insertVirusObject, "virus_id", virus_id);
				cJSON_AddStringToObject(insertVirusObject, "imphash", "");
				cJSON_AddNumberToObject(insertVirusObject, "is_cert", 0);
				cJSON_AddStringToObject(insertVirusObject, "cert_signer", "");
				cJSON_AddStringToObject(insertVirusObject, "cert_details", "");
				cJSON_AddStringToObject(insertVirusObject, "cmdline", cmdline);
				cJSON_AddNumberToObject(insertVirusObject, "is_service", 0);
				cJSON_AddStringToObject(insertVirusObject, "proc_service_name", "");
				if (strlen(tcpinfo)>0 ||strlen(udpinfo)>0)
				{
					char netInfo[1024]={""};
					strcat(netInfo,"{\"TCP_STAT\":\"");
					strcat(netInfo,tcpinfo);
					strcat(netInfo,"\",");
					strcat(netInfo,"\"UDP_STAT\":\"");
					strcat(netInfo,udpinfo);
					strcat(netInfo,"\"}");
					cJSON_AddStringToObject(insertVirusObject, "info", netInfo);
				}else{
					cJSON_AddStringToObject(insertVirusObject, "info", "");
				}
				free(file_md5);
			}
			//不是病毒
			if(isVirus==0){

				char file_id[5];
				if(g_scanCount>99999){
					exit(0);
				}
				sprintf(file_id,"%d",g_scanCount);
				
				//获取文件md5
				char *file_md5=fileMd5(g_virus_path);
			
				//获取文件大小			
				int file_size=get_file_size(g_virus_path);
				
				//获取文件时间属性
				int access=getFileTimeInfo(g_virus_path,access_time,create_time,modify_time);
				if (access==1)
				{
					
					cJSON_AddItemToArray(hashReportArray,hashReportObject=cJSON_CreateObject());
					
					cJSON_AddStringToObject(hashReportObject, "section_hash", g_file_hash);
					cJSON_AddNumberToObject(hashReportObject, "section_size", g_virus_size);
					cJSON_AddStringToObject(hashReportObject, "total_md5", file_md5);
					cJSON_AddStringToObject(hashReportObject, "file_path", g_virus_path);
					cJSON_AddNumberToObject(hashReportObject, "file_size", file_size);
					cJSON_AddStringToObject(hashReportObject, "access_time", access_time);
					cJSON_AddStringToObject(hashReportObject, "create_time", create_time);
					cJSON_AddStringToObject(hashReportObject, "modify_time", modify_time);
					cJSON_AddStringToObject(hashReportObject, "virus_id", file_id);
					cJSON_AddStringToObject(hashReportObject, "imphash", "");
					cJSON_AddNumberToObject(hashReportObject, "is_cert", 0);
					cJSON_AddStringToObject(hashReportObject, "cert_signer", "");
					cJSON_AddStringToObject(hashReportObject, "cert_details", "");
					cJSON_AddStringToObject(hashReportObject, "cmdline", cmdline);
					cJSON_AddNumberToObject(hashReportObject, "is_service", 0);
					cJSON_AddStringToObject(hashReportObject, "proc_service_name", "");
					if (strlen(tcpinfo)>0 ||strlen(udpinfo)>0)
					{
						char netInfo[1024]={""};
						strcat(netInfo,"{\"TCP_STAT\":\"");
						strcat(netInfo,tcpinfo);
						strcat(netInfo,"\",");
						strcat(netInfo,"\"UDP_STAT\":\"");
						strcat(netInfo,udpinfo);
						strcat(netInfo,"\"}");
						cJSON_AddStringToObject(hashReportObject, "info", netInfo);
					}else{
						cJSON_AddStringToObject(hashReportObject, "info", "");
					}
					//cJSON_AddStringToObject(hashReportObject, "data", "");
					
				}

				free(file_md5);
				
			}
			//僵尸进程
			if(isVirus==-1){
				g_virusCount++;
				char nofile_id[5]={""};
				sprintf(nofile_id,"%d",no_file_id);
				cJSON_AddItemToArray(insertVirusArray,insertVirusObject=cJSON_CreateObject());
				cJSON_AddStringToObject(insertVirusObject, "virus_name", "File deleted");
				cJSON_AddStringToObject(insertVirusObject, "section_hash", nofile_hash);
				cJSON_AddNumberToObject(insertVirusObject, "section_size", 0);
				cJSON_AddStringToObject(insertVirusObject, "file_md5", "00000000000000000000000000000000");
				cJSON_AddNumberToObject(insertVirusObject, "file_size", 0);
				cJSON_AddStringToObject(insertVirusObject, "imphash", "");
				cJSON_AddNumberToObject(insertVirusObject, "is_cert", 0);
				cJSON_AddStringToObject(insertVirusObject, "cert_signer", "");
				cJSON_AddStringToObject(insertVirusObject, "cert_details", "");
				cJSON_AddStringToObject(insertVirusObject, "cmdline", cmdline);
				cJSON_AddNumberToObject(insertVirusObject, "is_service", 0);
				cJSON_AddStringToObject(insertVirusObject, "proc_service_name", "");
				cJSON_AddStringToObject(insertVirusObject, "virus_path", path);
				cJSON_AddStringToObject(insertVirusObject, "parent_path", "");
				cJSON_AddStringToObject(insertVirusObject, "remote_ip", zombie_ip);
				cJSON_AddStringToObject(insertVirusObject, "killed", "Not kill");
				cJSON_AddNumberToObject(insertVirusObject, "proc_runtime", 0);
				cJSON_AddStringToObject(insertVirusObject, "access_time", "");
				cJSON_AddStringToObject(insertVirusObject, "create_time", "");
				cJSON_AddStringToObject(insertVirusObject, "modify_time", "");
				cJSON_AddStringToObject(insertVirusObject, "virus_id", nofile_id);
				
				
				if (strlen(tcpinfo)>0 ||strlen(udpinfo)>0)
				{
					char netInfo[1024]={""};
					strcat(netInfo,"{\"TCP_STAT\":\"");
					strcat(netInfo,tcpinfo);
					strcat(netInfo,"\",");
					strcat(netInfo,"\"UDP_STAT\":\"");
					strcat(netInfo,udpinfo);
					strcat(netInfo,"\"}");
					cJSON_AddStringToObject(insertVirusObject, "info", netInfo);
				}else{
					cJSON_AddStringToObject(insertVirusObject, "info", "");
				}
				no_file_id++;

			}

			free(cmdline);
			free(zombie_ip);
			free(tcpinfo);
			free(udpinfo);
			free(access_time);
			free(create_time);
			free(modify_time);
		}
		free(path_hash);
		free(link);
		free(path);
	}
	//mapFileHash.clear();
	//上报病毒信息
	if(g_virusCount>0 || g_packedCount>0 ){
		char* insertVirusStr=cJSON_Print(insertVirusJsonRoot);
		//printf("%s\n",insertVirusStr);
		int insertVirusResult=reportJsonBody(insertVirusStr,1);
		int insertRetryTimes=0;
		while(insertVirusResult==0){
			sleep(3);
			insertVirusResult=reportJsonBody(insertVirusStr,2);
			insertRetryTimes++;
		}
        free(insertVirusStr);
	}
    
	cJSON_Delete(insertVirusJsonRoot);
	


	//上报进程网络快照
	char* hashReportStr=cJSON_Print(hashReportJsonRoot);
	//printf("%s\n",hashReportStr);
	int reportJsonBodyResult=reportJsonBody(hashReportStr,2);
	int reportRetryTimes=0;
	while(reportJsonBodyResult==0){
		sleep(3);
		reportJsonBodyResult=reportJsonBody(hashReportStr,2);
		reportRetryTimes++;
	}
	
    free(hashReportStr);
	cJSON_Delete(hashReportJsonRoot);
	     
}

//判断数字
int is_num(char *d_name){
        int i,size;
        size = strlen(d_name);
        if(size==0) return -1;
        
        // determine if the dir name is number ;
        for(i=0;i<size;i++)
                if(d_name[i]<'0' || d_name[i]>'9') return -1;
        return 0;
}

//进程扫描
int procScan()
{
        struct proc_list *head = inport_list("/proc");
        if(head==NULL){
                printf("inport list failed !\n");        
        } 
        getPathNotClean(head);
        free_list(head);
        return 0;
}