#include <stdio.h>
#include <string.h>
 
//Change hexadecimal number to decimal number
int HexToInt(char h)
{
    if(h >= '0' && h <= '9')
    {
        return h - '0';
    }
    else if(h >= 'A' && h <= 'F')
    {
        return h - 'A' + 10;
    }
    else
    {
        //cerr << "Error: Illegal Hex Number!" << endl;
        return -1;
    }
}

int my_itoa(int val, char* buf)
{
	const unsigned int radix = 10;
	char* p;
	unsigned int a; //every digit
	int len;
	char* b; //start of the digit char
	char temp;
	unsigned int u;
	p = buf;
	if (val < 0)
	{
		*p++ = '-';
		val = 0 - val;
	}
	u = (unsigned int)val;
	b = p;
	do{
		a = u % radix;
		u /= radix;
		*p++ = a + '0';
	} while (u > 0);
	len = (int)(p - buf);
	*p-- = 0;
	//swap
	do{
	temp = *p;
	*p = *b;
	*b = temp;
	--p;
	++b;
	} while (b < p);
	return len;
}


char *GetIpAddress(char* str)
{
    int a, b, c, d, e;
     
    a = HexToInt(str[0]) * 16 + HexToInt(str[1]);
    b = HexToInt(str[2]) * 16 + HexToInt(str[3]);
    c = HexToInt(str[4]) * 16 + HexToInt(str[5]);
    d = HexToInt(str[6]) * 16 + HexToInt(str[7]);
    e = HexToInt(str[9]) * 16 * 16 * 16 +
        HexToInt(str[10]) * 16 * 16 +
        HexToInt(str[11]) * 16 +
        HexToInt(str[12]);
	char ipstr[40]={""};
	char s1[4];
	char s2[4];
	char s3[4];
	char s4[4];
	char s5[8];
	my_itoa(d,s1);
	strncat(ipstr,s1,sizeof(s1));
	strncat(ipstr,".",1);
	my_itoa(c,s2);
	strncat(ipstr,s2,sizeof(s2));
	strncat(ipstr,".",1);
	my_itoa(b,s3);
	strncat(ipstr,s3,sizeof(s3));
	strncat(ipstr,".",1);
	my_itoa(a,s4);
	strncat(ipstr,s4,sizeof(s4));
	my_itoa(e,s5);
	strncat(ipstr,":",1);
	strncat(ipstr,s5,sizeof(s5));
	static char ip_str[40];
	strncpy(ip_str,ipstr,sizeof(ipstr));
    return ip_str;
}


char *GetIpAddress2(char* str)
{
    int a, b, c, d, e;
     
    a = HexToInt(str[0]) * 16 + HexToInt(str[1]);
    b = HexToInt(str[2]) * 16 + HexToInt(str[3]);
    c = HexToInt(str[4]) * 16 + HexToInt(str[5]);
    d = HexToInt(str[6]) * 16 + HexToInt(str[7]);
    e = HexToInt(str[9]) * 16 * 16 * 16 +
        HexToInt(str[10]) * 16 * 16 +
        HexToInt(str[11]) * 16 +
        HexToInt(str[12]);
	char ipstr[40]={""};
	char s1[4];
	char s2[4];
	char s3[4];
	char s4[4];
	char s5[8];
	my_itoa(d,s1);
	strncat(ipstr,s1,sizeof(s1));
	strncat(ipstr,".",1);
	my_itoa(c,s2);
	strncat(ipstr,s2,sizeof(s2));
	strncat(ipstr,".",1);
	my_itoa(b,s3);
	strncat(ipstr,s3,sizeof(s3));
	strncat(ipstr,".",1);
	my_itoa(a,s4);
	strncat(ipstr,s4,sizeof(s4));
	my_itoa(e,s5);
	strncat(ipstr,":",1);
	strncat(ipstr,s5,sizeof(s5));
	static char ip_str[40];
	strncpy(ip_str,ipstr,sizeof(ipstr));
    return ip_str;
}
 
//Get tcp connection state
char* GetConnectionState(char* str)
{
    if(str[0] == '0' && str[1] == '0') return "ERROR_STATUS";
    if(str[0] == '0' && str[1] == '1') return "ESTABLISHED";
    if(str[0] == '0' && str[1] == '2') return "SYN_SENT";
    if(str[0] == '0' && str[1] == '3') return "SYN_RECV";
    if(str[0] == '0' && str[1] == '4') return "FIN_WAIT1";
    if(str[0] == '0' && str[1] == '5') return "FIN_WAIT2";
    if(str[0] == '0' && str[1] == '6') return "TIME_WAIT";
    if(str[0] == '0' && str[1] == '7') return "CLOSE";
    if(str[0] == '0' && str[1] == '8') return "CLOSE_WAIT";
    if(str[0] == '0' && str[1] == '9') return "LAST_ACK";
    if(str[0] == '0' && str[1] == 'A') return "LISTEN";
    if(str[0] == '0' && str[1] == 'B') return "CLOSING";
    return "UNKNOWN_STATE";
}

void getTcpInfoByInode(int t_inode,char *tcp_local_ip,int tcp_local_ip_size,char *tcp_remote_ip,int tcp_remote_ip_size,char *tcp_state,int tcp_state_size)
{
	FILE * pFile;
	char mystring [200];
	int count=0;
	pFile = fopen ("/proc/net/tcp" , "r");
	if (pFile == NULL){
		perror ("Error opening file");
		exit(0);
	}
        
	while( fgets (mystring , 200 , pFile) != NULL){
		if(count==0 ){
			count++;
			continue;
		}
		if(count>5){
			break;
		}
		char s_local_addr[40], s_remote_addr[40], s_state[20],s_inode[20];
		sscanf(mystring, "%*s%s%s%s%*s%*s%*s%*s%*s%s%*s%*s%*s%*s%*s%*s%*s", s_local_addr, s_remote_addr, s_state,s_inode);
		int inode=atoi(s_inode);
		char* conn_state = GetConnectionState(s_state);
		//判断inode相等
		if(t_inode==inode && strcmp(conn_state,"UNKNOWN_STATE")!=0){
			char* temp_local_ip = GetIpAddress2(s_local_addr);
			char* temp_remote_ip = GetIpAddress(s_remote_addr);
			char* temp_state =GetConnectionState(s_state);
			strncpy(tcp_local_ip,temp_local_ip,tcp_local_ip_size);
			strncpy(tcp_remote_ip,temp_remote_ip,tcp_remote_ip_size);
			strncpy(tcp_state,temp_state,tcp_state_size);
			break;
		}
	}
	fclose (pFile);
}

void getUdpInfoByInode(int t_inode,char *udp_local_ip,int udp_local_ip_size,char *udp_remote_ip,int udp_remote_ip_size,char *udp_state,int udp_state_size)
{
	FILE * pFile;
	char mystring [200];
	int count=0;
	pFile = fopen ("/proc/net/udp" , "r");
	if (pFile == NULL){
		perror ("Error opening file");
		exit(0);
	}
        
	while( fgets (mystring , 200 , pFile) != NULL){
		if(count==0 ){
			count++;
			continue;
		}
		if(count>3){
			break;
		}
		char s_local_addr[40], s_remote_addr[40], s_state[20],s_inode[20];
		//printf("%s\n",mystring);
		sscanf(mystring, "%*s%s%s%s%*s%*s%*s%*s%*s%s%*s%*s%*s%*s%*s%*s%*s", s_local_addr, s_remote_addr, s_state,s_inode);
		//printf("%s\n",mystring);
		int inode=atoi(s_inode);
		char* conn_state = GetConnectionState(s_state);
		//printf("s_inode:%s\n",s_inode);
		//printf("inode:%d\nt_inode:%d\n",inode,t_inode);
		//判断inode相等
		if(t_inode==inode && strcmp(conn_state,"UNKNOWN_STATE")!=0){
		
			//printf("%s\t%s\t%s\t\n",s_local_addr,s_remote_addr,s_state);
			char* temp_local_ip = GetIpAddress2(s_local_addr);
			char* temp_remote_ip = GetIpAddress(s_remote_addr);
			char* temp_state =GetConnectionState(s_state);
			//	strncat(tcp_Info,tcp_state,sizeof(tcp_state));
			//printf("%s\t%s\t%s\t\n",temp_local_ip,temp_remote_ip,temp_state);
			strncpy(udp_local_ip,temp_local_ip,udp_local_ip_size);
			strncpy(udp_remote_ip,temp_remote_ip,udp_remote_ip_size);
			strncpy(udp_state,temp_state,udp_state_size);
			break;
		}
	}
	fclose (pFile);
}


void getNetInfoByPid(int pid,char *tcpinfo,int tcpinfo_size,char *udpinfo,int udpinfo_size,char *zombie_ip,int zombie_ip_size){
	char link[100]={""},fd[20]={""};
	int i=0;
	static char getTcpInfoByPid_result[60];
	for(i=0;i<20;i++){
		sprintf(link, "/proc/%d/fd/%d",pid,i);
		//printf("%s\n",link);
		int flag=readlink(link, fd, sizeof(fd));
		if(flag!=-1){
			char *buf=NULL;
			//printf("%s\n",fd);
			char temp[]="[";
			buf=strstr(fd,temp);
			if(buf!=NULL){
				char *inode=NULL;
				int k;
				sscanf(buf,"%*[^0-9]%i",&k);
				
				int tcp_local_ip_size=40;
				char *tcp_local_ip = malloc(tcp_local_ip_size*(sizeof(char)));
				if(tcp_local_ip == NULL) return 0;
					memset(tcp_local_ip,0,tcp_local_ip_size*sizeof(char));
				int tcp_remote_ip_size=40;
				char *tcp_remote_ip = malloc(tcp_remote_ip_size*(sizeof(char)));
				if(tcp_remote_ip == NULL) return 0;
					memset(tcp_remote_ip,0,tcp_remote_ip_size*sizeof(char)); 
				int tcp_state_size=20;
				char *tcp_state = malloc(tcp_state_size*(sizeof(char)));
				if(tcp_state == NULL) return 0;
					memset(tcp_state,0,tcp_state_size*sizeof(char)); 
				//printf("Pid:%d\n",pid);
				
				int udp_local_ip_size=40;
				char *udp_local_ip = malloc(udp_local_ip_size*(sizeof(char)));
				if(udp_local_ip == NULL) return 0;
					memset(udp_local_ip,0,udp_local_ip_size*sizeof(char));
				int udp_remote_ip_size=40;
				char *udp_remote_ip = malloc(udp_remote_ip_size*(sizeof(char)));
				if(udp_remote_ip == NULL) return 0;
					memset(udp_remote_ip,0,udp_remote_ip_size*sizeof(char)); 
				int udp_state_size=20;
				char *udp_state = malloc(udp_state_size*(sizeof(char)));
				if(udp_state == NULL) return 0;
					memset(udp_state,0,udp_state_size*sizeof(char)); 
					
				getTcpInfoByInode(k,tcp_local_ip,tcp_local_ip_size,tcp_remote_ip,tcp_remote_ip_size,tcp_state,tcp_state_size);
				getUdpInfoByInode(k,udp_local_ip,udp_local_ip_size,udp_remote_ip,udp_remote_ip_size,udp_state,udp_state_size);
				if(strstr(tcp_remote_ip,":")!=NULL || strstr(tcp_local_ip,":")!=NULL){
					//tcp连接信息
					strncat(tcpinfo,tcp_local_ip,tcpinfo_size);
					strncat(tcpinfo,"\t",tcpinfo_size);
					strncat(tcpinfo,tcp_remote_ip,tcpinfo_size);
					strncat(tcpinfo," ",tcpinfo_size);
					strncat(tcpinfo,tcp_state,tcpinfo_size);
					strncat(tcpinfo,"\n",tcpinfo_size);
					
					strncat(zombie_ip,tcp_remote_ip,zombie_ip_size);
					strncat(zombie_ip," ",zombie_ip_size);
					strncat(zombie_ip,tcp_state,zombie_ip_size);
					strncat(zombie_ip,";",zombie_ip_size);
					
				}
				
				if(strstr(udp_remote_ip,":")!=NULL || strstr(udp_local_ip,":")!=NULL){
					//udp连接信息
					strncat(udpinfo,udp_local_ip,udpinfo_size);
					strncat(udpinfo,"\t",udpinfo_size);
					strncat(udpinfo,udp_remote_ip,udpinfo_size);
					strncat(udpinfo," ",udpinfo_size);
					strncat(udpinfo,udp_state,udpinfo_size);
					strncat(udpinfo,"\n",udpinfo_size);
					strncat(zombie_ip,udp_remote_ip,zombie_ip_size);
					strncat(zombie_ip," ",zombie_ip_size);
					strncat(zombie_ip,udp_state,zombie_ip_size);
					strncat(zombie_ip,";",zombie_ip_size);
				}
				free(tcp_local_ip);
				free(tcp_remote_ip);
				free(tcp_state);
				free(udp_local_ip);
				free(udp_remote_ip);
				free(udp_state);
				}
		}
	}
}
